# Background

At time of writing, there are Kafka JDBC Sink Connector that reads data from a Kakfa topic and and write them back into Database.

It is SQL Server that involved in the actual project, due to nature of data, `upsert` mode is chosen (the `insert.mode` config of the sink connector). `upsert` means `MERGE` statement is used for the case of SQL Server. Meanwhile, there is another connector config option, which is `mssql.use.merge.holdlock` which when enabled, uses `HOLDLOCK` when performing a `MERGE INTO` statement.

With this setting, the actual SQL statement generated by the connector looks like:
```
merge into "dummy" with (HOLDLOCK) AS target
  using (select ? AS "id", ? AS "name") AS incoming
  on (target."id"=incoming."id")
  when matched then
    update set "name"=incoming."name"
  when not matched then
    insert ("name", "id") values (incoming."name",incoming."id");
```

It is said `HOLDLOCK` enables `SERIALIZABLE` isolation level, and results in the use of range lock and results in deadlock.
(ref: https://sqlsunday.com/2021/05/04/how-merge-can-deadlock-you/)

# Table Definition

```
CREATE TABLE dbo.ApplicationState (
    id          int NOT NULL,
    val         int NOT NULL,
    PRIMARY KEY CLUSTERED (id)
);

INSERT INTO dbo.ApplicationState (id, val)
VALUES (100, 0),
       (10000, 0);
```

# Scenario1 - `UPDLOCK` on row that does not exist

1. Connection 1:
```
DECLARE @id int=500, @val int=501;

BEGIN TRANSACTION;

    IF (EXISTS (SELECT *
                FROM dbo.ApplicationState WITH (UPDLOCK)
                WHERE id=@id)
        ) BEGIN;

        WAITFOR DELAY '00:00:10';

        UPDATE dbo.ApplicationState
        SET val=@val
        WHERE id=@id;

    END ELSE BEGIN;

        WAITFOR DELAY '00:00:10';

        INSERT INTO dbo.ApplicationState (id, val)
        VALUES (@id, @val);      

    END;

COMMIT TRANSACTION;
```

2. Connection 2: (start after connection1, e.g. 1 second after)
`INSERT INTO dbo.ApplicationState (id, val)  VALUES (1000, 1001);`

## Conclusion
- Connection 2 inserts successfully without waiting
- Connection 1 runs into duplicate key error.
- `UPDLOCK` itself does not lock row that does not exist

# Scenario2 - `UPDLOCK` on row that exists
Assuming the row already exists, then run Connection 1 and 2 codes in order.

## Conclusion
- Connection 2 runs into duplicate key error this time after Connection completes successfully
- `UPDLOCK` locks the row that exists

# Scenario3 - `HOLDLOCK` starts range locking and causes deadlock
Similar to Scenario1, but use `HOLDLOCK` instead of `UPDLOCK`.

1. Connection 1
```
DECLARE @id int=500, @val int=5000;
BEGIN TRANSACTION;

    IF (EXISTS (SELECT *
                FROM dbo.ApplicationState WITH (HOLDLOCK)
                WHERE id=@id)
) BEGIN;

        WAITFOR DELAY '00:00:10';

        UPDATE dbo.ApplicationState
        SET val=@val
        WHERE id=@id;

    END ELSE BEGIN;

        WAITFOR DELAY '00:00:12';

 INSERT INTO dbo.ApplicationState (id, val)
        VALUES (@id, @val);       

    END;

COMMIT TRANSACTION;
```

2. Connection 2
```
DECLARE @id int=1000, @val int=1001;
BEGIN TRANSACTION;
	MERGE INTO dbo.ApplicationState WITH (HOLDLOCK) AS t
	USING (
	        VALUES (@id, @val)
	    ) AS s(id, val) ON (t.id=s.id)

	WHEN NOT MATCHED THEN
	    INSERT (id, val)
	    VALUES (s.id, s.val)

	WHEN MATCHED THEN
	    UPDATE
	    SET t.val=s.val;


COMMIT;
```

## Conclusion
`HOLDLOCK` starts a range lock, even though connection 1 and 2 are on different ids, they both claimed a shared  range lock.
While one of the connection wants to update or insert within the range, they need an exclusive lock so as to make a change.

A **deadlock** is created because both are waiting for the other one to give away the shared range lock. Runtime chooses one of the connection as victim and so the other connection will continue.

The chosen victim encounter error explaining what happened.

# Scenario4 - `HOLDLOCK` when rows exist
same as Scenario3 but the rows already exist
## Conclusion
Connection 1 completes successfully
Connection 2 completes successfully without waiting at all
- This is because connection 1 does not really require a range lock when row exists

# Scenario5 - Use both `UPDLOCK` and `HOLDLOCK`
When the rows do not exist
or, when the row for connection 1 does not exist, but the row for connect 2 exists
- Connection 1 completes successfully
- Connection 2 runs successfully after waiting for Connection 1 to finish
- Because row1 does not exist, connection 1 requires range lock, connection 2 needs to wait

When both rows exist
or, When the row for connection 1 exists, but the row for connection 2 does not exist
- Connection 1 completes successfully
- Conclusion 2 completes successfully without waiting at all
- Because row1 exists, connection 1 does not need range lock, but row lock is sufficient.

# Scenario6 - Use both `UPDLOCK` and `HOLDLOCK` can still lead to deadlock
If connection1 starts a transaction, upserts row1 first, then row2 while not yet committed the transaction; similarly connection 2 upserts row2 first, then row1 while not yet committed the transaction; a deadlock is created. Full SQL:

Connection 1
```

DECLARE @id int=500, @val int=500;
DECLARE @id2 int=501, @val2 int=501;

BEGIN TRANSACTION;

    IF (EXISTS (SELECT *
                FROM dbo.ApplicationState WITH (UPDLOCK, HOLDLOCK)
                WHERE id=@id)
        ) BEGIN;

        UPDATE dbo.ApplicationState
        SET val=@val
        WHERE id=@id;

    END ELSE BEGIN;

        INSERT INTO dbo.ApplicationState(id, val)
        VALUES (@id, @val);       

    END;

    WAITFOR DELAY '00:00:10';

    IF (EXISTS (SELECT *
                FROM dbo.ApplicationState WITH (UPDLOCK, HOLDLOCK)
                WHERE id=@id2)
        ) BEGIN;


        UPDATE dbo.ApplicationState
        SET val=@val2
        WHERE id=@id2;

    END ELSE BEGIN;

        INSERT INTO dbo.ApplicationState(id, val)
        VALUES (@id2, @val2);       

    END;

COMMIT TRANSACTION;
```

Connection 2:
```
DECLARE @id int=500, @val int=503;
DECLARE @id2 int=501, @val2 int=504;

BEGIN TRANSACTION;

	MERGE INTO dbo.ApplicationState WITH (UPDLOCK, HOLDLOCK) AS t
	USING (
	        VALUES (@id2, @val2)
	    ) AS s(id, val) ON (t.id=s.id)

	WHEN NOT MATCHED THEN
	    INSERT (id, val)
	    VALUES (s.id, s.val)

	WHEN MATCHED THEN
	    UPDATE
	    SET t.val=s.val;

    WAITFOR DELAY '00:00:15';

	MERGE INTO dbo.ApplicationState WITH (UPDLOCK, HOLDLOCK) AS t
	USING (
	        VALUES (@id, @val)
	    ) AS s(id, val) ON (t.id=s.id)

	WHEN NOT MATCHED THEN
	    INSERT (id, val)
	    VALUES (s.id, s.val)

	WHEN MATCHED THEN
	    UPDATE
	    SET t.val=s.val+1;

COMMIT;
```
